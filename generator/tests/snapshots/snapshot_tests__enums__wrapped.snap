---
source: generator/tests/snapshot_tests.rs
expression: output
---
/* ============================== Wrapped =============================== */

export function isWrapped(type: string): boolean {
  type = compressSuiType(type)
  return type.startsWith(`${getTypeOrigin('examples', 'example::ExampleStruct')}::enums::Wrapped` + '<')
}

export interface WrappedFields<T extends TypeArgument, U extends TypeArgument, V extends TypeArgument> {
  id: ToField<UID>
  t: ToField<T>
  u: ToField<U>
  v: ToField<V>
  stop: ToField<ActionVariant<'u64', ToPhantom<SUI>>>
  pause: ToField<ActionVariant<'u64', ToPhantom<SUI>>>
  jump: ToField<ActionVariant<'u64', ToPhantom<SUI>>>
}

export type WrappedReified<T extends TypeArgument, U extends TypeArgument, V extends TypeArgument> = Reified<Wrapped<T, U, V>, WrappedFields<T, U, V>>

export class Wrapped<T extends TypeArgument, U extends TypeArgument, V extends TypeArgument> implements StructClass {
  __StructClass = true as const

  static readonly $typeName = `${getTypeOrigin('examples', 'example::ExampleStruct')}::enums::Wrapped` as const
  static readonly $numTypeParams = 3
  static readonly $isPhantom = [false, false, false] as const

  readonly $typeName = Wrapped.$typeName
  readonly $fullTypeName: `${string}::enums::Wrapped<${ToTypeStr<T>}, ${ToTypeStr<U>}, ${ToTypeStr<V>}>`
  readonly $typeArgs: [ToTypeStr<T>, ToTypeStr<U>, ToTypeStr<V>]
  readonly $isPhantom = Wrapped.$isPhantom

  readonly id: ToField<UID>
  readonly t: ToField<T>
  readonly u: ToField<U>
  readonly v: ToField<V>
  readonly stop: ToField<ActionVariant<'u64', ToPhantom<SUI>>>
  readonly pause: ToField<ActionVariant<'u64', ToPhantom<SUI>>>
  readonly jump: ToField<ActionVariant<'u64', ToPhantom<SUI>>>

  private constructor(typeArgs: [ToTypeStr<T>, ToTypeStr<U>, ToTypeStr<V>], fields: WrappedFields<T, U, V>) {
    this.$fullTypeName = composeSuiType(
      Wrapped.$typeName,
      ...typeArgs
    ) as `${string}::enums::Wrapped<${ToTypeStr<T>}, ${ToTypeStr<U>}, ${ToTypeStr<V>}>`
    this.$typeArgs = typeArgs

    this.id = fields.id
    this.t = fields.t
    this.u = fields.u
    this.v = fields.v
    this.stop = fields.stop
    this.pause = fields.pause
    this.jump = fields.jump
  }

  static reified<T extends Reified<TypeArgument, any>, U extends Reified<TypeArgument, any>, V extends Reified<TypeArgument, any>>(
    T: T, U: U, V: V
  ): WrappedReified<ToTypeArgument<T>, ToTypeArgument<U>, ToTypeArgument<V>> {
    const reifiedBcs = Wrapped.bcs(toBcs(T), toBcs(U), toBcs(V))
    return {
      typeName: Wrapped.$typeName,
      fullTypeName: composeSuiType(
        Wrapped.$typeName,
        ...[extractType(T), extractType(U), extractType(V)]
      ) as `${string}::enums::Wrapped<${ToTypeStr<ToTypeArgument<T>>}, ${ToTypeStr<ToTypeArgument<U>>}, ${ToTypeStr<ToTypeArgument<V>>}>`,
      typeArgs: [extractType(T), extractType(U), extractType(V)] as [ToTypeStr<ToTypeArgument<T>>, ToTypeStr<ToTypeArgument<U>>, ToTypeStr<ToTypeArgument<V>>],
      isPhantom: Wrapped.$isPhantom,
      reifiedTypeArgs: [T, U, V],
      fromFields: (fields: Record<string, any>) => Wrapped.fromFields([T, U, V], fields),
      fromFieldsWithTypes: (item: FieldsWithTypes) => Wrapped.fromFieldsWithTypes([T, U, V], item),
      fromBcs: (data: Uint8Array) => Wrapped.fromFields([T, U, V], reifiedBcs.parse(data)),
      bcs: reifiedBcs,
      fromJSONField: (field: any) => Wrapped.fromJSONField([T, U, V], field),
      fromJSON: (json: Record<string, any>) => Wrapped.fromJSON([T, U, V], json),
      fromSuiParsedData: (content: SuiParsedData) => Wrapped.fromSuiParsedData([T, U, V], content),
      fromSuiObjectData: (content: SuiObjectData) => Wrapped.fromSuiObjectData([T, U, V], content),
      fetch: async (client: SupportedSuiClient, id: string) => Wrapped.fetch(client, [T, U, V], id),
      new: (fields: WrappedFields<ToTypeArgument<T>, ToTypeArgument<U>, ToTypeArgument<V>>) => {
        return new Wrapped([extractType(T), extractType(U), extractType(V)], fields)
      },
      kind: 'StructClassReified',
    }
  }

  static get r() {
    return Wrapped.reified
  }

  static phantom<T extends Reified<TypeArgument, any>, U extends Reified<TypeArgument, any>, V extends Reified<TypeArgument, any>>(
    T: T, U: U, V: V
  ): PhantomReified<ToTypeStr<Wrapped<ToTypeArgument<T>, ToTypeArgument<U>, ToTypeArgument<V>>>> {
    return phantom(Wrapped.reified(T, U, V))
  }

  static get p() {
    return Wrapped.phantom
  }

  private static instantiateBcs() {
    return <T extends BcsType<any>, U extends BcsType<any>, V extends BcsType<any>>(T: T, U: U, V: V) =>
      bcs.struct(`Wrapped<${T.name}, ${U.name}, ${V.name}>`, {
      id: UID.bcs,
      t: T,
      u: U,
      v: V,
      stop: Action.bcs(bcs.u64()),
      pause: Action.bcs(bcs.u64()),
      jump: Action.bcs(bcs.u64()),
      })
  }

  private static cachedBcs: ReturnType<typeof Wrapped.instantiateBcs> | null = null

  static get bcs(): ReturnType<typeof Wrapped.instantiateBcs> {
    if (!Wrapped.cachedBcs) {
      Wrapped.cachedBcs = Wrapped.instantiateBcs()
    }
    return Wrapped.cachedBcs
  }

  static fromFields<T extends Reified<TypeArgument, any>, U extends Reified<TypeArgument, any>, V extends Reified<TypeArgument, any>>(
    typeArgs: [T, U, V],
    fields: Record<string, any>
  ): Wrapped<ToTypeArgument<T>, ToTypeArgument<U>, ToTypeArgument<V>> {
    return Wrapped.reified(typeArgs[0], typeArgs[1], typeArgs[2]).new({
      id: decodeFromFields(UID.reified(), fields.id),
      t: decodeFromFields(typeArgs[0], fields.t),
      u: decodeFromFields(typeArgs[1], fields.u),
      v: decodeFromFields(typeArgs[2], fields.v),
      stop: decodeFromFields(Action.reified('u64', phantom(SUI.reified())), fields.stop),
      pause: decodeFromFields(Action.reified('u64', phantom(SUI.reified())), fields.pause),
      jump: decodeFromFields(Action.reified('u64', phantom(SUI.reified())), fields.jump),
    })
  }

  static fromFieldsWithTypes<T extends Reified<TypeArgument, any>, U extends Reified<TypeArgument, any>, V extends Reified<TypeArgument, any>>(
    typeArgs: [T, U, V],
    item: FieldsWithTypes
  ): Wrapped<ToTypeArgument<T>, ToTypeArgument<U>, ToTypeArgument<V>> {
    if (!isWrapped(item.type)) {
      throw new Error('not a Wrapped type')
    }
    assertFieldsWithTypesArgsMatch(item, typeArgs)

    return Wrapped.reified(typeArgs[0], typeArgs[1], typeArgs[2]).new({
      id: decodeFromFieldsWithTypes(UID.reified(), item.fields.id),
      t: decodeFromFieldsWithTypes(typeArgs[0], item.fields.t),
      u: decodeFromFieldsWithTypes(typeArgs[1], item.fields.u),
      v: decodeFromFieldsWithTypes(typeArgs[2], item.fields.v),
      stop: decodeFromFieldsWithTypes(Action.reified('u64', phantom(SUI.reified())), item.fields.stop),
      pause: decodeFromFieldsWithTypes(Action.reified('u64', phantom(SUI.reified())), item.fields.pause),
      jump: decodeFromFieldsWithTypes(Action.reified('u64', phantom(SUI.reified())), item.fields.jump),
    })
  }

  static fromBcs<T extends Reified<TypeArgument, any>, U extends Reified<TypeArgument, any>, V extends Reified<TypeArgument, any>>(
    typeArgs: [T, U, V],
    data: Uint8Array
  ): Wrapped<ToTypeArgument<T>, ToTypeArgument<U>, ToTypeArgument<V>> {
    return Wrapped.fromFields(typeArgs, Wrapped.bcs(toBcs(typeArgs[0]), toBcs(typeArgs[1]), toBcs(typeArgs[2])).parse(data))
  }

  toJSONField() {
    return {
      id: this.id,
      t: fieldToJSON<T>(`${this.$typeArgs[0]}`, this.t),
      u: fieldToJSON<U>(`${this.$typeArgs[1]}`, this.u),
      v: fieldToJSON<V>(`${this.$typeArgs[2]}`, this.v),
      stop: this.stop.toJSONField(),
      pause: this.pause.toJSONField(),
      jump: this.jump.toJSONField(),
    }
  }

  toJSON() {
    return { $typeName: this.$typeName, $typeArgs: this.$typeArgs, ...this.toJSONField() }
  }

  static fromJSONField<T extends Reified<TypeArgument, any>, U extends Reified<TypeArgument, any>, V extends Reified<TypeArgument, any>>(
    typeArgs: [T, U, V],
    field: any
  ): Wrapped<ToTypeArgument<T>, ToTypeArgument<U>, ToTypeArgument<V>> {
    return Wrapped.reified(typeArgs[0], typeArgs[1], typeArgs[2]).new({
      id: decodeFromJSONField(UID.reified(), field.id),
      t: decodeFromJSONField(typeArgs[0], field.t),
      u: decodeFromJSONField(typeArgs[1], field.u),
      v: decodeFromJSONField(typeArgs[2], field.v),
      stop: decodeFromJSONField(Action.reified('u64', phantom(SUI.reified())), field.stop),
      pause: decodeFromJSONField(Action.reified('u64', phantom(SUI.reified())), field.pause),
      jump: decodeFromJSONField(Action.reified('u64', phantom(SUI.reified())), field.jump),
    })
  }

  static fromJSON<T extends Reified<TypeArgument, any>, U extends Reified<TypeArgument, any>, V extends Reified<TypeArgument, any>>(
    typeArgs: [T, U, V],
    json: Record<string, any>
  ): Wrapped<ToTypeArgument<T>, ToTypeArgument<U>, ToTypeArgument<V>> {
    if (json.$typeName !== Wrapped.$typeName) {
      throw new Error(`not a Wrapped json object: expected '${Wrapped.$typeName}' but got '${json.$typeName}'`)
    }
    assertReifiedTypeArgsMatch(
      composeSuiType(Wrapped.$typeName, ...typeArgs.map(extractType)),
      json.$typeArgs,
      typeArgs
    )

    return Wrapped.fromJSONField(typeArgs, json)
  }

  static fromSuiParsedData<T extends Reified<TypeArgument, any>, U extends Reified<TypeArgument, any>, V extends Reified<TypeArgument, any>>(
    typeArgs: [T, U, V],
    content: SuiParsedData
  ): Wrapped<ToTypeArgument<T>, ToTypeArgument<U>, ToTypeArgument<V>> {
    if (content.dataType !== 'moveObject') {
      throw new Error('not an object')
    }
    if (!isWrapped(content.type)) {
      throw new Error(`object at ${(content.fields as any).id} is not a Wrapped object`)
    }
    return Wrapped.fromFieldsWithTypes(typeArgs, content)
  }

  static fromSuiObjectData<T extends Reified<TypeArgument, any>, U extends Reified<TypeArgument, any>, V extends Reified<TypeArgument, any>>(
    typeArgs: [T, U, V],
    data: SuiObjectData
  ): Wrapped<ToTypeArgument<T>, ToTypeArgument<U>, ToTypeArgument<V>> {
    if (data.bcs) {
      if (data.bcs.dataType !== 'moveObject' || !isWrapped(data.bcs.type)) {
        throw new Error(`object at is not a Wrapped object`)
      }

      const gotTypeArgs = parseTypeName(data.bcs.type).typeArgs
      if (gotTypeArgs.length !== 3) {
        throw new Error(
          `type argument mismatch: expected 3 type arguments but got '${gotTypeArgs.length}'`
        )
      }
      for (let i = 0; i < 3; i++) {
        const gotTypeArg = compressSuiType(gotTypeArgs[i])
        const expectedTypeArg = compressSuiType(extractType(typeArgs[i]))
        if (gotTypeArg !== expectedTypeArg) {
          throw new Error(
            `type argument mismatch at position ${i}: expected '${expectedTypeArg}' but got '${gotTypeArg}'`
          )
        }
      }

      return Wrapped.fromBcs(typeArgs, fromBase64(data.bcs.bcsBytes))
    }
    if (data.content) {
      return Wrapped.fromSuiParsedData(typeArgs, data.content)
    }
    throw new Error(
      'Both `bcs` and `content` fields are missing from the data. Include `showBcs` or `showContent` in the request.'
    )
  }

  static async fetch<T extends Reified<TypeArgument, any>, U extends Reified<TypeArgument, any>, V extends Reified<TypeArgument, any>>(
    client: SupportedSuiClient,
    typeArgs: [T, U, V],
    id: string
  ): Promise<Wrapped<ToTypeArgument<T>, ToTypeArgument<U>, ToTypeArgument<V>>> {
    const res = await fetchObjectBcs(client, id)
    if (!isWrapped(res.type)) {
      throw new Error(`object at id ${id} is not a Wrapped object`)
    }

    return Wrapped.fromBcs(typeArgs, res.bcsBytes)
  }
}
